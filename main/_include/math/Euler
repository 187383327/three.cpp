//
// Created by byter on 29.07.17.
//

#ifndef THREECPP_EULER
#define THREECPP_EULER

#include <QObject>
#include <QMatrix4x4>
#include <QQuaternion>

namespace three {
namespace math {

class Euler : public QObject
{
  Q_OBJECT
  Q_PROPERTY(float x READ get_x WRITE set_x NOTIFIY changed)
  Q_PROPERTY(float y READ get_y WRITE set_y NOTIFIY changed)
  Q_PROPERTY(float z READ get_z WRITE set_z NOTIFIY changed)
  Q_PROPERTY(float z READ get_z WRITE set_z NOTIFIY changed)
  Q_PROPERTY(RotationOrder order READ get_order WRITE set_order NOTIFIY changed)

public:
  enum RotationOrder {XYZ, YZX, ZXY, XZY, YXZ, ZYX};
  Q_ENUM(RotationOrder)

  float get_x() {return _x;}
  void set_x(float x);
  float get_y() {return _y;}
  void set_y(float y);
  float get_z() {return _z;}
  void set_z(float z);
  RotationOrder get_order() {return _order;}
  void set_order(RotationOrder order);

private:
  float _x;
  float _y;
  float _z;
  RotationOrder _order;

signals:
  void changed();

public:
  Euler(float x, float y, float z, RotationOrder order) : _x(x), _y(y), _z(z), _order(order) {}
  Euler() : _x(0), _y(0), _z(0), _order(XYZ) {}

  Euler & operator = (const Euler &other);

  void set(float x, float y, float z, RotationOrder order);

  void setFromRotationMatrix(QMatrix4x4 m, bool update=true);
  void setFromRotationMatrix(QMatrix4x4 m, RotationOrder order, bool update);
  void setFromQuaternion(QQuaternion q, RotationOrder order, bool update=true);
  void setFromVector3(QVector3D v, RotationOrder order);
  void reorder(RotationOrder order);

  QQuaternion toQuaternion();

  bool operator ==(const Euler &other);
};

}
}

#endif //THREECPP_EULER
